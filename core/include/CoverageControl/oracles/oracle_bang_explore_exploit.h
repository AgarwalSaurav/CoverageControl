/**
 *
 **/

#ifndef COVERAGECONTROL_ORACLE_BANG_EXPLORE_EXPLOIT_H_
#define COVERAGECONTROL_ORACLE_BANG_EXPLORE_EXPLOIT_H_

#include <vector>
#include <fstream>
#include <iostream>
#include <random>
#include <algorithm>
#include <set>
#include <omp.h>

#include "../parameters.h"
#include "../typedefs.h"
#include "../coverage_system.h"
#include "../lloyd_algorithms.h"
#include <lsap/Hungarian.h>

namespace CoverageControl {

	class OracleBangExploreExploit {
		private:
			Parameters const params_;
			size_t num_robots_ = 0;
			CoverageSystem &env_;
			Voronoi voronoi_;
			std::vector <VoronoiCell> voronoi_cells_;
			PointVector robot_global_positions_;
			PointVector goals_, actions_;
			std::vector <std::vector<double>> cost_matrix_;
			MapType oracle_map_;
			MapType exploration_map_; // Binary map: true for unexplored locations
			MapType explored_idf_map_;
			double exploration_ratio_ = 1;
			int recompute_goal_steps_ = 0, recompute_goal_counter_ = 0;
			bool continue_flag_ = false;
			bool trigger_exploit_ = false;
			bool first_step_ = true;
			std::vector <int> robot_status_; // 0: exploring, 1: exploit
			std::vector <int> random_goal_counter_;
			std::set <int> exploring_robots_;
			std::set <int> exploiting_robots_;
			std::random_device rd_;  //Will be used to obtain a seed for the random number engine
			std::mt19937 gen_;
			std::uniform_real_distribution<> rand_dist_;
			double exploration_threshold_ = 0.2;
			double exploit_threshold_ = 0;
			double too_close_factor_ = 6.0;
			double sensor_area_ = 0;
			double local_win_ = 0;
			double time_step_dist_ = 0;

		public:
			OracleBangExploreExploit(
					Parameters const &params,
					size_t const &num_robots,
					CoverageSystem &env) :
				params_{params},
				num_robots_{num_robots},
				env_{env}{

				cost_matrix_.resize(num_robots_, std::vector<double>(num_robots_));
				voronoi_cells_.resize(num_robots_);

				robot_global_positions_ = env_.GetRobotPositions();
				actions_.resize(num_robots_);
				goals_ = robot_global_positions_;
				sensor_area_ = params_.pSensorSize * params_.pSensorSize;
				local_win_ = 4 * params_.pSensorSize;
				exploit_threshold_ = 0.2 * local_win_ * local_win_;

				robot_status_.resize(num_robots_, 0);
				random_goal_counter_.resize(num_robots_, 10);
				for(size_t i = 0; i < num_robots_; ++i) {
					exploring_robots_.insert(i);
				}

				std::srand(0);
				gen_ = std::mt19937(rd_()); //Standard mersenne_twister_engine seeded with rd_()

				time_step_dist_ = params_.pMaxRobotSpeed * params_.pTimeStep * params_.pResolution;
				rand_dist_ = std::uniform_real_distribution<>(-time_step_dist_, time_step_dist_);
				
				// The oracle map is designed to store the pixels seen by any robot
				oracle_map_ = MapType::Constant(params_.pWorldMapSize, params_.pWorldMapSize, 0);
				exploration_map_ = MapType::Constant(params_.pWorldMapSize, params_.pWorldMapSize, 1);
				explored_idf_map_ = MapType::Constant(params_.pWorldMapSize, params_.pWorldMapSize, 0);
				UpdateOracleMap();
				ComputeGoals();
			}

			PointVector GetActions() { return actions_; }

			MapType const& GetOracleMap() { return oracle_map_; }

			void SetGoals(PointVector const &goals) {
				goals_ = goals;
			}

			auto GetGoals() { return goals_; }

			std::vector<VoronoiCell> GetVoronoiCells() { return voronoi_cells_; }

			void UpdateOracleMap() {
				robot_global_positions_ = env_.GetRobotPositions();
				for(size_t i = 0; i < num_robots_; ++i) {
					MapUtils::MapBounds index, offset;
					MapUtils::ComputeOffsets(params_.pResolution, robot_global_positions_[i], params_.pSensorSize, params_.pWorldMapSize, index, offset);
					explored_idf_map_.block(index.left + offset.left, index.bottom + offset.bottom, offset.width, offset.height) = env_.GetRobotSensorView(i).block(offset.left, offset.bottom, offset.width, offset.height);
					exploration_map_.block(index.left + offset.left, index.bottom + offset.bottom, offset.width, offset.height) = MapType::Zero(params_.pSensorSize, params_.pSensorSize);
				}
				exploration_ratio_ = (double)(exploration_map_.count())/(params_.pWorldMapSize * params_.pWorldMapSize);
				oracle_map_ = explored_idf_map_ + 2 * exploration_ratio_ * exploration_map_;
			}

			double GetExplorationRatio() const { return exploration_ratio_; }

			void ManageRobotStatus() {
				robot_global_positions_ = env_.GetRobotPositions();
				for(size_t iRobot = 0; iRobot < num_robots_; ++iRobot) {
					robot_status_[iRobot] = 0;

					MapUtils::MapBounds index, offset;
					MapUtils::ComputeOffsets(params_.pResolution, robot_global_positions_[iRobot], local_win_, params_.pWorldMapSize, index, offset);
					double unexplored = exploration_map_.block(index.left + offset.left, index.bottom + offset.bottom, offset.width, offset.height).count();
					double idf_value = explored_idf_map_.block(index.left + offset.left, index.bottom + offset.bottom, offset.width, offset.height).count();

					if(unexplored < exploit_threshold_ and idf_value > exploit_threshold_) {
						robot_status_[iRobot] = 1;
						for(size_t jRobot = 0; jRobot < iRobot; ++jRobot) {
							double goal_dist = (goals_[iRobot] - goals_[jRobot]).norm();
							if(goal_dist < too_close_factor_ * params_.pSensorSize * params_.pResolution and exploration_ratio_ > exploration_threshold_ ) {
								robot_status_[jRobot] = 0;
							}
						}
					}
				}
			}

			double GetFrontierGoal(Point2 const &pos, Point2 &best_goal) {
				best_goal = pos;
				double best_bcr = 0, best_benefit = 0;
				double pos_x_lim = std::min(pos[0] + time_step_dist_, double(params_.pWorldMapSize));
				double pos_y_lim = std::min(pos[1] + time_step_dist_, double(params_.pWorldMapSize));
				for(double pos_x = std::max(pos[0] - time_step_dist_, 0.); pos_x < pos_x_lim;  pos_x += 2 * params_.pResolution ) {
					for(double pos_y = std::max(pos[1] - time_step_dist_, 0.); pos_y < pos_y_lim; pos_y += 2 * params_.pResolution ) {
						Point2 qpos{ pos_x, pos_y };
						double dist = (qpos - pos).norm();
						/* if(dist < 2 * params_.pResolution) { continue; } */
						dist = std::max(dist, time_step_dist_);
						MapUtils::MapBounds index, offset;
						MapUtils::ComputeOffsets(params_.pResolution, qpos, params_.pSensorSize, params_.pWorldMapSize, index, offset);
						double unexplored = exploration_map_.block(index.left + offset.left, index.bottom + offset.bottom, offset.width, offset.height).count();
						double benefit = unexplored;
						if(unexplored > 0.1 * sensor_area_) {
							double idf_value = explored_idf_map_.block(index.left + offset.left, index.bottom + offset.bottom, offset.width, offset.height).count();
							benefit += 2 * idf_value;
						}

						double bcr = benefit/dist;
						if(bcr > best_bcr + kEps) {
							best_bcr = bcr;
							best_goal = qpos;
							best_benefit = benefit;
						}
					}
				}
				/* std::cout << "Best goal: " << best_bcr << " " << best_goal[0] << " " << best_goal[1] << std::endl; */
				return best_benefit;
			}

			void ComputeGoals() {

				/* Exploration Robots */
				ManageRobotStatus();

#pragma omp parallel for num_threads(num_robots_)
				for(size_t iRobot = 0; iRobot < num_robots_; ++iRobot) {
					if(robot_status_[iRobot] == 0) {
						double best_benefit = GetFrontierGoal(robot_global_positions_[iRobot], goals_[iRobot]);
						if(best_benefit < 2) {
							robot_status_[iRobot] = 1;
						}
						/* std::cout << iRobot << " " << robot_status_[iRobot] << " " << (goals_[iRobot] - robot_global_positions_[iRobot]).norm() << " " << goals_[iRobot][0] << " " << goals_[iRobot][1] << std::endl; */
					}
				}

				/* Exploiting Robots */
				PointVector exploit_robots_pos;
				std::vector <int> exploit_robots;
				for(size_t iRobot = 0; iRobot < num_robots_; ++iRobot) {
					if(robot_status_[iRobot] != 0) {
						exploit_robots_pos.push_back(robot_global_positions_[iRobot]);
						exploit_robots.push_back(iRobot);
					}
				}

				Voronoi exploit_voronoi(exploit_robots_pos, explored_idf_map_, params_.pWorldMapSize, params_.pResolution);
				auto exploit_voronoi_cells = exploit_voronoi.GetVoronoiCells();

				for(size_t iCell = 0; iCell < exploit_robots.size(); ++iCell) {
					size_t iRobot = exploit_robots[iCell];
					goals_[iRobot] = exploit_voronoi_cells[iCell].centroid;
				}

				int num_exploring_robots = num_robots_ - exploit_robots.size();
				/* std::cout << "Number of exploring_robots: " << num_exploring_robots << std::endl; */
				/* std::cout << "Exploration ratio: " << exploration_ratio_ * 100 << std::endl; */

				if(num_exploring_robots == 0) {
					goals_ = LloydOffline(params_.pLloydNumTries, params_.pLloydMaxIterations, num_robots_, explored_idf_map_, params_.pWorldMapSize, params_.pResolution, robot_global_positions_);
					trigger_exploit_ = true;
				}

			}

			bool Step() {
				if(first_step_ == true) {
					first_step_ = false;
					robot_global_positions_ = env_.GetRobotPositions();
					for(size_t iRobot = 0; iRobot < num_robots_; ++iRobot) {
						goals_[iRobot] = robot_global_positions_[iRobot] + Point2{ rand_dist_(gen_), rand_dist_(gen_) };
					}

				} else if (trigger_exploit_ == false) {
					ComputeGoals();
				}
				env_.StepRobotsToGoals(goals_, actions_);
				continue_flag_ = false;
				for(size_t iRobot = 0; iRobot < num_robots_; ++iRobot) {
					/* printf("Step: %ld, %d, (%f, %f) \t (%f, %f)\n", iRobot, robot_status_[iRobot], goals_[iRobot][0], goals_[iRobot][1], actions_[iRobot][0], actions_[iRobot][1]); */
					if(actions_[iRobot].norm() > 0.0001) {
						continue_flag_ = true;
					}
				}
				UpdateOracleMap();
				return continue_flag_;
			}

	};

} /* namespace CoverageControl */
#endif /* COVERAGECONTROL_ORACLE_BANG_EXPLORE_EXPLOIT_H_ */

/*
 * This file is part of the CoverageControl library
 *
 * Author: Saurav Agarwal
 * Contact: sauravag@seas.upenn.edu, agr.saurav1@gmail.com
 * Repository: https://github.com/KumarRobotics/CoverageControl
 *
 * Copyright (c) 2024, Saurav Agarwal
 *
 * The CoverageControl library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * The CoverageControl library is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * CoverageControl library. If not, see <https://www.gnu.org/licenses/>.
 */

#include <CoverageControl/algorithms/oracle_bang_explore_exploit.h>
#include <CoverageControl/algorithms/oracle_explore_exploit.h>
#include <CoverageControl/algorithms/simul_explore_exploit.h>
#include <CoverageControl/bivariate_normal_distribution.h>
#include <CoverageControl/constants.h>
#include <CoverageControl/coverage_system.h>
#include <CoverageControl/generate_world_map.h>
#include <CoverageControl/parameters.h>
#include <CoverageControl/robot_model.h>
#include <CoverageControl/typedefs.h>
#include <CoverageControl/world_idf.h>

#include <chrono>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>

using namespace CoverageControl;

int main(int argc, char** argv) {
  Parameters params;
  /* params.pSensorSize = 16; */
  /* params.pMaxRobotSpeed = 10; */
  if (argc == 2) {
    std::string parameter_file = argv[1];
    params = Parameters(parameter_file);
  }

  PointVector frontiers;
  int num_robots = 15;
  int num_dists = 10;
  CoverageSystem env(params, num_dists, num_robots);
  OracleSimulExploreExploit oracle(params, num_robots, env);

  std::string dir = "data/oracle/";
  env.PlotWorldMap(dir, "world_map");
  env.RecordPlotData();
  for (int ii = 1; ii < params.pEpisodeSteps; ++ii) {
    std::cout << "Step: " << ii << std::endl;
    bool cont_flag = oracle.Step();
    auto actions = oracle.GetActions();
    if (env.StepActions(actions)) {
      std::cerr << "Error: StepActions" << std::endl;
      break;
    }
    auto robot_status = oracle.GetRobotStatus();
    if (ii % 1 == 0) {
      frontiers = oracle.GetFrontiers();
      env.RecordPlotData(robot_status);
    }
    if (cont_flag == false) {
      break;
    }
  }
  std::cout << "Converged" << std::endl;
  std::cout << "Exploration ratio: " << env.GetExplorationRatio()
            << " Weighted: " << env.GetWeightedExplorationRatio() << std::endl;

  auto robot_status = oracle.GetRobotStatus();
  auto zero_actions = PointVector(num_robots, Point2(0, 0));

  for (int ii = 0; ii < 90; ++ii) {
    if (env.StepActions(zero_actions)) {
      std::cerr << "Error: StepActions" << std::endl;
      break;
    }
    env.RecordPlotData(robot_status);
  }
  env.RenderRecordedMap(dir, "CoverageControl_ExploreExploit.mp4");

  return 0;
}
